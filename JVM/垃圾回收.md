## 垃圾回收

### 垃圾回收主要思考三件事情：

- 那种内存需要回收？
- 什么时候回收？
- 怎么回收？

### 对象是否存活

#### 引用计数法

这是一种非常简单易理解的回收算法。每当有一个地方引用一个对象的时候则在引用计数器上+1，当失效的时候就-1，无论什么时候计数器为0的时候则认为该对象死亡可以回收了。

这种算法虽然简单高效，但是却无法解决循环引用的问题，因此Java虚拟机并没有采用这种算法。

#### 可达性分析算法

主流语言其实都采用可达性分析算法：

可达性分析算法是通过一个称为GC Roots的对象向下搜索，整个搜索路径就称为引用链，当一个对象到GC Roots没有 任何引用链JVM就认为该对象是可以被回收的。

![可达性分析算法](https://github.com/jasonli822/java_technology_stack/blob/master/images/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/1.jpeg)



如图:Object1、2、3、4 都是存活的对象，而 Object5、6、7都是可回收对象。

可以用作GC-Roots的对象有：

- 方法区中的静态变量所引用的对象。

- 虚拟机栈中所引用的对象。


### 垃圾回收算法

#### 标记-清除算法

标记清除算法分为两个步骤，标记和清除。首先讲需要回收的对象标记起来，然后统一清除。但是存在两个主要问题：

- 标记和清除的效率都不高
- 清除之后容易出现不连续内存，当需要分配一个较大内存时就不得不需要进行一次垃圾回收。

标记清除过程如下：

![标记-清除算法](https://github.com/jasonli822/java_technology_stack/blob/master/images/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/2.jpeg)

#### 复制算法

复制算法是将内存划分为两块大小相等的区域，每次使用时都只用其中的一块区域，当发生垃圾回收时会将存活的对象全部复制到未使用的区域，然后对之前的区域进行全部回收。

这样简单高效，而且还不存在标记清除算法中内存碎片问题，但就是有点浪费内存。

新生代中分为一个Eden区和两个Survivor区。通常两个区域的比例是8:1:1，使用时会用到Eden区和其中一个Survivor区。当发生回收时则会将还存活的对象从Eden,Survivor区拷贝到另一个Survivor区，当该区域内存也不足时则会使用分配担保利用老年代来存放内存。

复制算法过程：

![复制算法](https://github.com/jasonli822/java_technology_stack/blob/master/images/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/3.jpeg)

#### 标记整理算法

复制算法如果在存活对象较多时效率明显会降低，特别是在老年代中并没有多余的内存区域可以提供内存担保。

所以老年代中使用的是`分配整理算法`，它的原理和`分配清除算法`类似，只是最后一步的清除改为了将存活对象全部移动到另一端，然后再将边界之外的内存全部回收。

![标记整理算法](https://github.com/jasonli822/java_technology_stack/blob/master/images/JVM/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/4.jpeg)

#### 分代回收算法

现代多数的商用JVM垃圾收集器都是采用分代回收算法，和之前所提供的算法并没有新的内容。

只是将Java堆分为了新生代和老年代。由于新生代中存活对象较少，所以采用复制算法，简单高效。

而老年代中对象较多，并且没有可以担保的内存区域，所以一般采用标记清除或者是标记整理算法。